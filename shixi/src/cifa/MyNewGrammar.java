/* MyNewGrammar.java */
/* Generated By:JJTree&JavaCC: Do not edit this line. MyNewGrammar.java */
package cifa;
import util.*;
import java.io.*;
import java.util.ArrayList;

public class MyNewGrammar/*@bgen(jjtree)*/implements MyNewGrammarTreeConstants, MyNewGrammarConstants {/*@bgen(jjtree)*/
  protected JJTMyNewGrammarState jjtree = new JJTMyNewGrammarState();public QTList qtList = new QTList();

  public StatementType ST = new StatementType();

  public VariableTable Vt = new VariableTable();

  public void printQTTable(char [] buffer, FileWriter fos)
  {
    qtList.printQTTable(buffer, fos);
  }

  public static void main(String args [])
  {
    try
    {
      File outFile = new File("cifa.txt");
      FileWriter fos = new FileWriter(outFile);
      File outFile1 = new File("yufa.txt");
      FileWriter fos1 = new FileWriter(outFile1);
      File outFile2 = new File("yuyi.txt");
      FileWriter fos2 = new FileWriter(outFile2);

      FileReader reader = new FileReader("test_error.txt");
      FileReader reader1 = new FileReader("test_error.txt");

      char [] buffer = new char [10000];
      MyNewGrammar parser = new MyNewGrammar(reader);

      Token t = null;
      SimpleCharStream stream = new SimpleCharStream(reader1);
      MyNewGrammarTokenManager tmg = new MyNewGrammarTokenManager(stream);
      t = tmg.getNextToken();

      System.out.println("\u8bcd\u6cd5\u5206\u6790:\n");//词法分析
      String st = new String("\u8bcd\u6cd5\u5206\u6790:\n");
      buffer = st.toCharArray();
      fos.write(buffer);
      while (t.kind != 0)
      {
        System.out.println(t.kind + " --- " + t.image);
        st = new String(t.kind + " --- " + t.image + "\n");
        buffer = st.toCharArray();
        fos.write(buffer);
        t = tmg.getNextToken();
      }
      System.out.println("\n");

      System.out.println("\u8bed\u6cd5\u5206\u6790: ");//语法分析
      st = new String("\u8bed\u6cd5\u5206\u6790:\n");
      buffer = st.toCharArray();
      fos1.write(buffer);
      SimpleNode n = parser.Start();
      n.dump(" ", buffer, fos1);

      System.out.println("\u8bed\u4e49\u5206\u6790: \n");//语义分析
      st = new String("\u8bed\u4e49\u5206\u6790: \n");
      buffer = st.toCharArray();
      fos2.write(buffer);
      parser.printQTTable(buffer, fos2);

      fos2.close();
      fos.close();
      fos1.close();
      reader.close();
      reader1.close();
    }
    catch (Exception e)
    {
      System.out.println("Oops.");
      System.out.println(e.getMessage());
      e.printStackTrace();
    }
  }

  final public SimpleNode Start() throws ParseException {/*@bgen(jjtree) Start */
  SimpleNode jjtn000 = new SimpleNode(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Program();
jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
}

  final public void Program() throws ParseException {/*@bgen(jjtree) Program */
  SimpleNode jjtn000 = new SimpleNode(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Type();
      jj_consume_token(MAIN);
      jj_consume_token(LB);
      jj_consume_token(RB);
      jj_consume_token(ZUOHUAKUO);
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case INT:
        case VOID:
        case DOUBLE:
        case IF:
        case WHILE:
        case FOR:
        case SWITCH:
        case DO:
        case CHAR:
        case FLOAT:
        case SHORT:
        case LONG:
        case BOOL:
        case RETURN:
        case ZUOHUAKUO:
        case IDENTIFIER:{
          ;
          break;
          }
        default:
          jj_la1[0] = jj_gen;
          break label_1;
        }
        SentenceBlock();
      }
      jj_consume_token(YOUHUAKUO);
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
}

  final public String Type() throws ParseException {/*@bgen(jjtree) Type */
  SimpleNode jjtn000 = new SimpleNode(JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case INT:{
        t = jj_consume_token(INT);
jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
{if ("" != null) return t.image;}
        break;
        }
      case DOUBLE:{
        t = jj_consume_token(DOUBLE);
jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
{if ("" != null) return t.image;}
        break;
        }
      case VOID:{
        t = jj_consume_token(VOID);
jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
{if ("" != null) return t.image;}
        break;
        }
      case FLOAT:{
        t = jj_consume_token(FLOAT);
jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
{if ("" != null) return t.image;}
        break;
        }
      case CHAR:{
        t = jj_consume_token(CHAR);
jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
{if ("" != null) return t.image;}
        break;
        }
      case LONG:{
        t = jj_consume_token(LONG);
jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
{if ("" != null) return t.image;}
        break;
        }
      case SHORT:{
        t = jj_consume_token(SHORT);
jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
{if ("" != null) return t.image;}
        break;
        }
      case BOOL:{
        t = jj_consume_token(BOOL);
jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
{if ("" != null) return t.image;}
        break;
        }
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
}

  final public void SentenceBlock() throws ParseException {/*@bgen(jjtree) SentenceBlock */
  SimpleNode jjtn000 = new SimpleNode(JJTSENTENCEBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case INT:
      case VOID:
      case DOUBLE:
      case IF:
      case WHILE:
      case FOR:
      case SWITCH:
      case DO:
      case CHAR:
      case FLOAT:
      case SHORT:
      case LONG:
      case BOOL:
      case RETURN:
      case IDENTIFIER:{
        Sentence();
        break;
        }
      case ZUOHUAKUO:{
        jj_consume_token(ZUOHUAKUO);
        label_2:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case INT:
          case VOID:
          case DOUBLE:
          case IF:
          case WHILE:
          case FOR:
          case SWITCH:
          case DO:
          case CHAR:
          case FLOAT:
          case SHORT:
          case LONG:
          case BOOL:
          case RETURN:
          case ZUOHUAKUO:
          case IDENTIFIER:{
            ;
            break;
            }
          default:
            jj_la1[2] = jj_gen;
            break label_2;
          }
          SentenceBlock();
        }
        jj_consume_token(YOUHUAKUO);
        break;
        }
      default:
        jj_la1[3] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
}

  final public void Sentence() throws ParseException {/*@bgen(jjtree) Sentence */
  SimpleNode jjtn000 = new SimpleNode(JJTSENTENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case INT:
      case VOID:
      case DOUBLE:
      case CHAR:
      case FLOAT:
      case SHORT:
      case LONG:
      case BOOL:
      case RETURN:
      case IDENTIFIER:{
        SequenceSentence();
        break;
        }
      case IF:{
        ConditionSentence();
        break;
        }
      case WHILE:{
        LoopSentence();
        break;
        }
      case DO:{
        DoWhile();
        break;
        }
      case SWITCH:{
        SwitchSentence();
        break;
        }
      case FOR:{
        forSentence();
        break;
        }
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
}

  final public void SequenceSentence() throws ParseException {/*@bgen(jjtree) SequenceSentence */
  SimpleNode jjtn000 = new SimpleNode(JJTSEQUENCESENTENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case INT:
      case VOID:
      case DOUBLE:
      case CHAR:
      case FLOAT:
      case SHORT:
      case LONG:
      case BOOL:{
        StatementSentence();
        jj_consume_token(SP);
        break;
        }
      case IDENTIFIER:{
        AssignmentSentence();
        jj_consume_token(SP);
        break;
        }
      case RETURN:{
        ReturnSentence();
        jj_consume_token(SP);
        break;
        }
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
}

  final public void ReturnSentence() throws ParseException {/*@bgen(jjtree) ReturnSentence */
  SimpleNode jjtn000 = new SimpleNode(JJTRETURNSENTENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(RETURN);
      Expression();
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
}

  final public void StatementSentence() throws ParseException {/*@bgen(jjtree) StatementSentence */
  SimpleNode jjtn000 = new SimpleNode(JJTSTATEMENTSENTENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token to = null;
  Variable va = new Variable();
  String ty = null;
    try {
      ty = Type();
      to = Identifier();
va = new Variable(ty, to);
    Vt.addWithCheck(va);
    ST.setVariableTable(Vt);
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case DH:{
          ;
          break;
          }
        default:
          jj_la1[6] = jj_gen;
          break label_3;
        }
        jj_consume_token(DH);
        to = Identifier();
va = new Variable(ty, to);
      Vt.addWithCheck(va);
      ST.setVariableTable(Vt);
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
}

  final public void AssignmentSentence() throws ParseException {/*@bgen(jjtree) AssignmentSentence */
  SimpleNode jjtn000 = new SimpleNode(JJTASSIGNMENTSENTENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String str2 = null;
  String str1 = null;
  Token op, to;
  Variable va = new Variable();
    try {
      to = Identifier();
str1 = to.image;
va = Vt.variableExist(str1);
    if (va == null)
    {
      System.out.println("\u53d8\u91cf" + str1 + "\u672a\u5b9a\u4e49");
    }
      op = jj_consume_token(DENGYUHAO);
      str2 = Expression();
jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
QTInfo qt = new QTInfo(op.image, str2, "_", str1);
    qtList.addQTInfo(qt);
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
}

  final public void AssignmentSentence2() throws ParseException {/*@bgen(jjtree) AssignmentSentence2 */
  SimpleNode jjtn000 = new SimpleNode(JJTASSIGNMENTSENTENCE2);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String str2 = null;
  String str1 = null;
  Token op, to;
  Variable va = new Variable();
    try {
      to = Identifier();
str1 = to.image;
va = Vt.variableExist(str1);
    if (va == null)
    {
      System.out.println("\u53d8\u91cf" + str1 + "\u672a\u5b9a\u4e49");
    }
      op = jj_consume_token(DENGYUHAO);
      str2 = Expression();
jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
QTInfo qt = new QTInfo(op.image, str2, "_", str1);
    qtList.addQTInfo(qt);
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
}

  final public void ConditionSentence() throws ParseException {/*@bgen(jjtree) ConditionSentence */
  SimpleNode jjtn000 = new SimpleNode(JJTCONDITIONSENTENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);ConditionValue cValue = new ConditionValue();
  int index;
    try {
      jj_consume_token(IF);
      jj_consume_token(LB);
      cValue = Booler();
      jj_consume_token(RB);
cValue.backpatchTrueChain(QTInfo.size + 1);
      SentenceBlock();
cValue.backpatchFalseChain(QTInfo.size + 1);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ELSE:{
        jj_consume_token(ELSE);
QTInfo qtInfo = new QTInfo("j", "_", "_", "F");
      index = QTInfo.size;
      qtList.addQTInfo(qtInfo);

      cValue.backpatchFalseChain(QTInfo.size + 1);
        SentenceBlock();
qtInfo = qtList.get(index);
      qtInfo.setResult(QTInfo.size + 1);
        break;
        }
      default:
        jj_la1[7] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
}

  final public void LoopSentence() throws ParseException {/*@bgen(jjtree) LoopSentence */
  SimpleNode jjtn000 = new SimpleNode(JJTLOOPSENTENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);ConditionValue cValue = new ConditionValue();
  int index;
    try {
      jj_consume_token(WHILE);
      jj_consume_token(LB);
index = QTInfo.size + 1;
      cValue = Booler();
      jj_consume_token(RB);
cValue.backpatchTrueChain(QTInfo.size + 1);
      SentenceBlock();
jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
QTInfo qtInfo = new QTInfo("j", "_", "_", index);
    qtList.addQTInfo(qtInfo);
    cValue.backpatchFalseChain(QTInfo.size + 1);
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
}

  final public ConditionValue Condition() throws ParseException {/*@bgen(jjtree) Condition */
  SimpleNode jjtn000 = new SimpleNode(JJTCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String e1 = null;
  String e2 = null;
  Token r = null;
  ConditionValue cValue = new ConditionValue();
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case LB:
      case IDENTIFIER:{
        e1 = Expression();
        break;
        }
      default:
        jj_la1[8] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LT:
      case LE:
      case GT:
      case GE:{
        r = Rop();
        e2 = Expression();
        break;
        }
      default:
        jj_la1[9] = jj_gen;
        ;
      }
if (r == null || e1 == null)
    {
      if (e1 == null)
      {
        QTInfo qtInfo = new QTInfo("jnz", "_", "_", "T");
        qtList.addQTInfo(qtInfo);
        cValue.mergeTrue(qtInfo);
      }
      else
      {
        QTInfo qtInfo = new QTInfo("jnz", e1, "_", "T");
        qtList.addQTInfo(qtInfo);
        cValue.mergeTrue(qtInfo);
      }
    }
    else
    {
      QTInfo qtInfo = new QTInfo("j" + r.image, e1, e2, "T");
      qtList.addQTInfo(qtInfo);
      cValue.mergeTrue(qtInfo);
    }
   QTInfo qtInfo = new QTInfo("j", "_", "_", "F");
    qtList.addQTInfo(qtInfo);
    cValue.mergeFalse(qtInfo);
jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
{if ("" != null) return cValue;}
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
}

  final public Token Rop() throws ParseException {/*@bgen(jjtree) Rop */
  SimpleNode jjtn000 = new SimpleNode(JJTROP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LT:{
        t = jj_consume_token(LT);
jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
{if ("" != null) return t;}
        break;
        }
      case LE:{
        t = jj_consume_token(LE);
jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
{if ("" != null) return t;}
        break;
        }
      case GT:{
        t = jj_consume_token(GT);
jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
{if ("" != null) return t;}
        break;
        }
      case GE:{
        t = jj_consume_token(GE);
jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
{if ("" != null) return t;}
        break;
        }
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
}

  final public String Expression() throws ParseException {/*@bgen(jjtree) Expression */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String s = null;
    try {
      s = AdditiveExpression();
jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
{if ("" != null) return s;}
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
}

  final public String AdditiveExpression() throws ParseException {/*@bgen(jjtree) AdditiveExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTADDITIVEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String a = null;
  String b = null;
  String result = null;
  Token t = null;
    try {
      a = MultiplicativeExpression();
result = a;
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 88:
        case 89:{
          ;
          break;
          }
        default:
          jj_la1[11] = jj_gen;
          break label_4;
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 88:{
          t = jj_consume_token(88);
          break;
          }
        case 89:{
          t = jj_consume_token(89);
          break;
          }
        default:
          jj_la1[12] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        b = MultiplicativeExpression();
result = VariableNameGenerator.genVariableName();
      QTInfo qtInfo = new QTInfo(t.image, a, b, result);
      qtList.addQTInfo(qtInfo);
      a = result;
      }
jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
{if ("" != null) return result;}
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
}

  final public String MultiplicativeExpression() throws ParseException {/*@bgen(jjtree) MultiplicativeExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTMULTIPLICATIVEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String a = null;
  String b = null;
  String result = null;
  Token t = null;
    try {
      a = UnaryExpression();
result = a;
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 90:
        case 91:
        case 92:{
          ;
          break;
          }
        default:
          jj_la1[13] = jj_gen;
          break label_5;
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 90:{
          t = jj_consume_token(90);
          break;
          }
        case 91:{
          t = jj_consume_token(91);
          break;
          }
        case 92:{
          t = jj_consume_token(92);
          break;
          }
        default:
          jj_la1[14] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        b = UnaryExpression();
result = VariableNameGenerator.genVariableName();
      QTInfo qtInfo = new QTInfo(t.image, a, b, result);
      qtList.addQTInfo(qtInfo);
      a = result;
      }
jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
{if ("" != null) return result;}
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
}

  final public String UnaryExpression() throws ParseException {/*@bgen(jjtree) UnaryExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTUNARYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String str = null;
  Token to = null;
  Variable va = new Variable();
  Token t = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LB:{
        jj_consume_token(LB);
        str = Expression();
        jj_consume_token(RB);
        break;
        }
      case IDENTIFIER:{
        to = Identifier();
str = to.image;
      va = Vt.variableExist(str);
      if (va == null)
      {
        System.out.println("\u53d8\u91cf" + str + "\u672a\u5b9a\u4e49");
      }
        break;
        }
      case INTEGER_LITERAL:{
        str = Integer();
        break;
        }
      case FLOATING_POINT_LITERAL:{
        t = jj_consume_token(FLOATING_POINT_LITERAL);
str = t.image;
        break;
        }
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
{if ("" != null) return str;}
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
}

  final public Token Identifier() throws ParseException {/*@bgen(jjtree) Identifier */
  SimpleNode jjtn000 = new SimpleNode(JJTIDENTIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t = null;
    try {
      t = jj_consume_token(IDENTIFIER);
jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
{if ("" != null) return t;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
}

  final public String Integer() throws ParseException {/*@bgen(jjtree) Integer */
  SimpleNode jjtn000 = new SimpleNode(JJTINTEGER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t = null;
    try {
      t = jj_consume_token(INTEGER_LITERAL);
jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
{if ("" != null) return t.image;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
}

  final public ConditionValue Booler() throws ParseException {/*@bgen(jjtree) Booler */
  SimpleNode jjtn000 = new SimpleNode(JJTBOOLER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);ConditionValue Value = new ConditionValue();
  String str1 = null, str2 = null;
  Token op = null;
  Token op1 = null;
  ConditionValue Value2 = new ConditionValue();
  ConditionValue Valuet = new ConditionValue();
  int qtSize = QTInfo.size;
  QTInfo qt1;
  QTInfo qt2;
    try {
      str1 = Expression();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LT:
      case LE:
      case GT:
      case GE:{
        op = Rop();
        str2 = Expression();
        break;
        }
      default:
        jj_la1[16] = jj_gen;
        ;
      }
if (op != null)
    {
      qt1 = new QTInfo("J" + op.image, str1, str2, QTInfo.size + 3);
      qtList.addQTInfo(qt1);
    }
    else
    {
      qt1 = new QTInfo("Jnz", str1, "_", QTInfo.size + 3);
      qtList.addQTInfo(qt1);
    }
    qt2 = new QTInfo("J", "_", "_", "F");
    qtList.addQTInfo(qt2);
    Value.mergeFalse(qt2);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case YU:
      case HUO:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case YU:{
          op1 = jj_consume_token(YU);
Valuet = new ConditionValue();
        Valuet.mergeFalse(qt2);
        Value.backpatchTrueChain(QTInfo.size + 1);
          break;
          }
        case HUO:{
          op1 = jj_consume_token(HUO);
Valuet.mergeFalse(qt2);
          Valuet.backpatchFalseChain(QTInfo.size + 1);
          Value.backpatchFalseChain(QTInfo.size + 1);
          break;
          }
        default:
          jj_la1[17] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        Value2 = Booler();
if (op1.image.equals("&&"))
      {
        Value2.mergeFalse(qt2);
        Value2.backpatchFalseChain(QTInfo.size + 1);
      }
      if (op1.image.equals("||"))
      {
        Value2.mergeTrue(qt1);
        Value2.backpatchTrueChain(QTInfo.size + 1);
      }
      {if ("" != null) return Value2;}
        break;
        }
      default:
        jj_la1[18] = jj_gen;
        ;
      }
jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
{if ("" != null) return Value;}
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
}

  final public void SwitchSentence() throws ParseException {/*@bgen(jjtree) SwitchSentence */
  SimpleNode jjtn000 = new SimpleNode(JJTSWITCHSENTENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);ConditionValue Value = new ConditionValue();
  String str1 = null;
  String str2 = null;
  int qtSize = QTInfo.size;
  Token tok;
  Token tokx;

  ArrayList<Integer> breakChain = new ArrayList<Integer>();
  QTInfo breakJump;
    try {
      jj_consume_token(SWITCH);
      jj_consume_token(LB);
      tok = jj_consume_token(IDENTIFIER);
      jj_consume_token(RB);
      jj_consume_token(ZUOHUAKUO);
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case CASE:{
          ;
          break;
          }
        default:
          jj_la1[19] = jj_gen;
          break label_6;
        }
        jj_consume_token(CASE);
        tokx = jj_consume_token(INTEGER_LITERAL);
QTInfo qt1;
      if (tokx != null)
      {
        qt1 = new QTInfo("case", tok.image, tokx.image, QTInfo.size + 3);
        qtList.addQTInfo(qt1);
        Value.backpatchFalseChain(QTInfo.size);
        Value = new ConditionValue();
      }
      else
      {
        qt1 = new QTInfo("Jnz", tok.image, "_", QTInfo.size + 3);
        qtList.addQTInfo(qt1);
      }
      QTInfo qt2 = new QTInfo("J", "_", "_", "F");
      qtList.addQTInfo(qt2);
      Value.mergeFalse(qt2);
      Value.backpatchFalseChain(QTInfo.size + 2);
        jj_consume_token(COLON);
        label_7:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case INT:
          case VOID:
          case DOUBLE:
          case IF:
          case WHILE:
          case FOR:
          case SWITCH:
          case DO:
          case CHAR:
          case FLOAT:
          case SHORT:
          case LONG:
          case BOOL:
          case RETURN:
          case ZUOHUAKUO:
          case IDENTIFIER:{
            ;
            break;
            }
          default:
            jj_la1[20] = jj_gen;
            break label_7;
          }
          SentenceBlock();
        }
        jj_consume_token(BREAK);
breakJump = new QTInfo("j", "_", "_", "F");
       breakChain.add(QTInfo.size);
       qtList.addQTInfo(breakJump);
        jj_consume_token(SP);
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case DFLT:{
        jj_consume_token(DFLT);
        jj_consume_token(COLON);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case INT:
        case VOID:
        case DOUBLE:
        case IF:
        case WHILE:
        case FOR:
        case SWITCH:
        case DO:
        case CHAR:
        case FLOAT:
        case SHORT:
        case LONG:
        case BOOL:
        case RETURN:
        case ZUOHUAKUO:
        case IDENTIFIER:{
          SentenceBlock();
          break;
          }
        default:
          jj_la1[21] = jj_gen;
          ;
        }
        jj_consume_token(BREAK);
        jj_consume_token(SP);
        break;
        }
      default:
        jj_la1[22] = jj_gen;
        ;
      }
      jj_consume_token(YOUHUAKUO);
jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
for(Integer i : breakChain) {
        qtList.get(i).setResult(QTInfo.size + 1);
     }
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
}

  final public void DoWhile() throws ParseException {/*@bgen(jjtree) DoWhile */
  SimpleNode jjtn000 = new SimpleNode(JJTDOWHILE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);int QTSize = QTInfo.size;
  ConditionValue Value = null;
  String str1 = null;
  String str2 = null;
  Token op = null;
    try {
      jj_consume_token(DO);
      SentenceBlock();
      jj_consume_token(WHILE);
      jj_consume_token(LB);
      Value = Booler();
      jj_consume_token(RB);
      jj_consume_token(SP);
Value.backpatchTrueChain(QTSize + 1);
jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
Value.backpatchFalseChain(QTInfo.size + 1);
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
}

  final public void forSentence() throws ParseException {/*@bgen(jjtree) forSentence */
  SimpleNode jjtn000 = new SimpleNode(JJTFORSENTENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);ConditionValue cValue = new ConditionValue();
  int conditionIndex;
  int incrementIndex;
  int bodyIndex;
  QTInfo jumpToBody;
  QTInfo jumpToIncrement;
  QTInfo jumpToCondition;
    try {
      jj_consume_token(FOR);
      jj_consume_token(LB);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case INT:
      case VOID:
      case DOUBLE:
      case CHAR:
      case FLOAT:
      case SHORT:
      case LONG:
      case BOOL:
      case IDENTIFIER:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case INT:
        case VOID:
        case DOUBLE:
        case CHAR:
        case FLOAT:
        case SHORT:
        case LONG:
        case BOOL:{
          StatementSentence();
          break;
          }
        case IDENTIFIER:{
          AssignmentSentence2();
          break;
          }
        default:
          jj_la1[23] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
        }
      default:
        jj_la1[24] = jj_gen;
        ;
      }
      jj_consume_token(SP);
conditionIndex = QTInfo.size + 1;
      cValue = Booler();
      jj_consume_token(SP);
jumpToBody = new QTInfo("J", "_", "_", 0);
    qtList.addQTInfo(jumpToBody);
    incrementIndex = QTInfo.size + 1;
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case IDENTIFIER:{
          ;
          break;
          }
        default:
          jj_la1[25] = jj_gen;
          break label_8;
        }
        AssignmentSentence2();
      }
jumpToCondition = new QTInfo("J", "_", "_", conditionIndex);
    qtList.addQTInfo(jumpToCondition);
    bodyIndex = QTInfo.size + 1;
    jumpToBody.setResult(bodyIndex);
    cValue.backpatchTrueChain(bodyIndex);
      jj_consume_token(RB);
      SentenceBlock();
jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
jumpToIncrement = new QTInfo("J", "_", "_", incrementIndex);
    qtList.addQTInfo(jumpToIncrement);
    cValue.backpatchFalseChain(QTInfo.size + 1);
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
}

  /** Generated Token Manager. */
  public MyNewGrammarTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[26];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
	   jj_la1_init_0();
	   jj_la1_init_1();
	   jj_la1_init_2();
	}
	private static void jj_la1_init_0() {
	   jj_la1_0 = new int[] {0xdf6d8000,0xdc058000,0xdf6d8000,0xdf6d8000,0xdf6d8000,0xdc058000,0x0,0x100000,0x880,0x0,0x0,0x0,0x0,0x0,0x0,0x880,0x0,0x0,0x0,0x20000000,0xdf6d8000,0xdf6d8000,0x800000,0xdc058000,0xdc058000,0x0,};
	}
	private static void jj_la1_init_1() {
	   jj_la1_1 = new int[] {0x400000,0x0,0x400000,0x400000,0x400000,0x400000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400000,0x400000,0x0,0x0,0x0,0x0,};
	}
	private static void jj_la1_init_2() {
	   jj_la1_2 = new int[] {0x208000,0x0,0x208000,0x208000,0x200000,0x200000,0x400,0x0,0x201000,0x3c,0x3c,0x3000000,0x3000000,0x1c000000,0x1c000000,0x201000,0x3c,0xc0,0xc0,0x0,0x208000,0x208000,0x0,0x200000,0x200000,0x200000,};
	}

  /** Constructor with InputStream. */
  public MyNewGrammar(java.io.InputStream stream) {
	  this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public MyNewGrammar(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source = new MyNewGrammarTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
	  ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jjtree.reset();
	 jj_gen = 0;
	 for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public MyNewGrammar(java.io.Reader stream) {
	 jj_input_stream = new SimpleCharStream(stream, 1, 1);
	 token_source = new MyNewGrammarTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
	if (jj_input_stream == null) {
	   jj_input_stream = new SimpleCharStream(stream, 1, 1);
	} else {
	   jj_input_stream.ReInit(stream, 1, 1);
	}
	if (token_source == null) {
 token_source = new MyNewGrammarTokenManager(jj_input_stream);
	}

	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jjtree.reset();
	 jj_gen = 0;
	 for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public MyNewGrammar(MyNewGrammarTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(MyNewGrammarTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jjtree.reset();
	 jj_gen = 0;
	 for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
	 Token oldToken;
	 if ((oldToken = token).next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 if (token.kind == kind) {
	   jj_gen++;
	   return token;
	 }
	 token = oldToken;
	 jj_kind = kind;
	 throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
	 if (token.next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 jj_gen++;
	 return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
	 Token t = token;
	 for (int i = 0; i < index; i++) {
	   if (t.next != null) t = t.next;
	   else t = t.next = token_source.getNextToken();
	 }
	 return t;
  }

  private int jj_ntk_f() {
	 if ((jj_nt=token.next) == null)
	   return (jj_ntk = (token.next=token_source.getNextToken()).kind);
	 else
	   return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
	 jj_expentries.clear();
	 boolean[] la1tokens = new boolean[93];
	 if (jj_kind >= 0) {
	   la1tokens[jj_kind] = true;
	   jj_kind = -1;
	 }
	 for (int i = 0; i < 26; i++) {
	   if (jj_la1[i] == jj_gen) {
		 for (int j = 0; j < 32; j++) {
		   if ((jj_la1_0[i] & (1<<j)) != 0) {
			 la1tokens[j] = true;
		   }
		   if ((jj_la1_1[i] & (1<<j)) != 0) {
			 la1tokens[32+j] = true;
		   }
		   if ((jj_la1_2[i] & (1<<j)) != 0) {
			 la1tokens[64+j] = true;
		   }
		 }
	   }
	 }
	 for (int i = 0; i < 93; i++) {
	   if (la1tokens[i]) {
		 jj_expentry = new int[1];
		 jj_expentry[0] = i;
		 jj_expentries.add(jj_expentry);
	   }
	 }
	 int[][] exptokseq = new int[jj_expentries.size()][];
	 for (int i = 0; i < jj_expentries.size(); i++) {
	   exptokseq[i] = jj_expentries.get(i);
	 }
	 return new ParseException(token, exptokseq, tokenImage);
  }

  private boolean trace_enabled;

/** Trace enabled. */
  final public boolean trace_enabled() {
	 return trace_enabled;
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
